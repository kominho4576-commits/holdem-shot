<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<meta name="theme-color" content="#7c6cf4">
<title>Hold’em&SHOT.io</title>
<link rel="manifest" href="manifest.webmanifest">
<link rel="icon" href="icons/icon-192.png">
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js" defer></script>
<style>
:root{ --ink:#7c6cf4; --line:#c7c1ff; --soft:#e7e3ff; }
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:#fff;color:var(--ink);font-family:system-ui,-apple-system,"Apple SD Gothic Neo",Segoe UI,Roboto,Helvetica,Arial,"Noto Sans KR",sans-serif}
button{border:3px solid var(--ink); background:#fff; color:var(--ink); padding:.6rem 1rem; border-radius:18px; font-weight:900; cursor:pointer; box-shadow:0 0 0 3px var(--soft) inset}
button:disabled{opacity:.5;cursor:not-allowed}
input{border:3px solid var(--ink); background:#fff; color:var(--ink); padding:.6rem 1rem; border-radius:18px; font-weight:800; width:100%; box-shadow:0 0 0 3px var(--soft) inset}
.title{font-size:clamp(28px,6vw,64px);font-weight:900;text-align:center;margin:32px 0 16px}
.container{max-width:980px;margin:0 auto;padding:0 16px 40px}
.sketch{border:4px solid var(--line);border-radius:18px;box-shadow:0 0 0 3px var(--soft) inset;padding:20px 18px;max-width:820px;margin:18px auto;}
.row{display:grid;grid-template-columns:1fr auto;gap:12px;align-items:center}
.status{display:flex;align-items:center;gap:8px;margin-top:12px}
.statusWrap{max-width:820px;margin:8px auto 0;padding:0 2px}
.dot{width:12px;height:12px;border-radius:50%;background:#e44}
.dot.on{background:#2ecc71}
.retry{font-size:.9rem;text-decoration:underline;cursor:pointer}
.helper{margin-top:10px;opacity:.85;font-size:.9rem}
.screen{display:none}
.screen.active{display:block}

/* PLAY */
.wrap{min-height:100vh;display:grid;grid-template-columns:1fr 2px 0.78fr;gap:0}
.board,.roulette{ border:4px solid var(--line); border-radius:20px; position:relative; min-height: calc(100vh - 24px); }
.divider{background:var(--line)}
.phase{position:absolute; top:18px; left:18px; font-size:28px; font-weight:900;}
.p2{position:absolute; top:22px; right:24px; display:flex; align-items:center; gap:12px; font-size:34px; font-weight:900; z-index:3;}
.p1{position:absolute; left:22px; bottom:26px; display:flex; align-items:center; gap:12px; font-size:42px; font-weight:900;}
.light{width:14px;height:14px;border-radius:50%; border:3px solid var(--ink); background:#fff; display:inline-block;}
.light.on{ background:#43d17a; border-color:#43d17a }

.handTop{position:absolute; left:50%; transform:translateX(-50%); top:92px; display:flex; gap:22px; z-index:2;}
.shared{position:absolute; left:60px; right:60px; top:310px; display:grid; grid-template-columns:repeat(5,130px); gap:20px; justify-content:center; justify-items:center; align-items:center; z-index:1;}
.card{width:130px; aspect-ratio:2.5/3.5; border:5px solid var(--line); border-radius:14px; display:flex; align-items:center; justify-content:center; font-weight:900; font-size:42px; color:var(--ink); background:#fff; position:relative; overflow:hidden; box-shadow:0 0 0 3px var(--soft) inset; user-select:none; transition:.1s; text-align:center}
.card .big{font-size:42px; line-height:1; }
.card .big.jokerLabel{ font-size:28px; letter-spacing:1px; }
.back::before{content:""; position:absolute; inset:0; background:repeating-linear-gradient(45deg, rgba(124,108,244,.45) 0 10px, rgba(124,108,244,.15) 10px 20px); opacity:.85;}
.face{background:linear-gradient(180deg,#fff 70%, rgba(124,108,244,.08));}
.handBottom{position:absolute; left:60px; bottom:120px; display:flex; gap:22px; align-items:center; z-index:5;}
.resultLine{position:absolute; left:60px; right:60px; top:520px; text-align:center; font-weight:900; opacity:.95}
.btns{position:absolute; right:120px; bottom:34px; display:flex; gap:12px; align-items:center; font-weight:800; z-index:6;}

.rwrap{height:100%; display:grid; place-items:center}
.drum{position:relative; width:min(420px,72vh); aspect-ratio:1/1; border:5px solid var(--line); border-radius:50%; box-shadow:0 0 0 3px var(--soft) inset; display:grid; place-items:center; overflow:visible; transition: transform 2.2s cubic-bezier(.22,.8,.25,1);}
.centerDot{width:18px; height:18px; border-radius:50%; background:#7c6cf4; opacity:.6}
.hole{position:absolute; width:84px; height:84px; border-radius:50%; border:5px solid var(--line); background:#fff; display:grid; place-items:center; box-shadow:0 0 0 3px var(--soft) inset;}
.hole .bullet{width:46px; height:46px; border-radius:50%; background:#5b5b5b; box-shadow:inset 0 0 0 10px #2b2b2b;}
.hole.selected{outline:4px solid var(--ink); outline-offset:3px; animation:pulse 600ms ease-in-out 1;}
@keyframes pulse{0%{transform:scale(1)}60%{transform:scale(1.07)}100%{transform:scale(1)}}
.arrow{position:absolute; top:-22px; left:50%; transform:translateX(-50%); width:0;height:0;border-left:18px solid transparent;border-right:18px solid transparent;border-top:24px solid var(--ink);}
.infoLine{margin-top:8px;opacity:.85; text-align:center}
.activePanel{outline:4px solid var(--ink); outline-offset:-4px}
.card.selected{outline:4px solid var(--ink); box-shadow:0 0 0 3px var(--ink) inset}
.card.selected-opp{outline:4px dashed var(--ink);}
#rotate{position:fixed; inset:0; background:#fff; color:#7c6cf4; display:none; align-items:center; justify-content:center; text-align:center; padding:24px; z-index:1000;}
#flash{position:fixed; pointer-events:none; inset:0; background:rgba(255,0,0,0.28); opacity:0; z-index:999; }
@keyframes flash1 { 0%{opacity:0} 15%{opacity:1} 100%{opacity:0} }
.flashOnce{ animation: flash1 220ms ease-out 1; }
.spinner{width:40px;height:40px;border:5px solid var(--soft);border-top-color:var(--ink);border-radius:50%;animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
</style>
</head>
<body>
<div id="app"></div>

<script>
const API_BASE = "https://holdem-shot.onrender.com";
let socket = null;
let myId = null;
let matchTimer = null;
let currentRoomId = null;
let isLocal = false; // (옵션) 오프라인 폴백
let selection = new Set(); // 내 교환 선택 인덱스(최대 2)
let forceReveal = false;   // 쇼다운 이후 다음 라운드 시작 전까지 상대패 강제 공개

/* ---------- UI 초기화 ---------- */
const app = document.getElementById("app");
app.innerHTML = `
  <div id="screen-home" class="screen active" aria-hidden="false">
    <div class="title">Hold’em&SHOT.io</div>
    <div class="container">
      <div class="sketch">
        <div class="row">
          <input id="nickname" placeholder="Nickname" />
          <button id="btnQuick">Quick Match</button>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="btnCreate">Create Room</button>
          <div style="display:grid;grid-template-columns:1fr auto;gap:8px;">
            <input id="roomCode" placeholder="Room Code" readonly />
            <button id="btnCopy">Copy</button>
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <input id="joinCode" placeholder="Enter Code to Join" />
          <button id="btnJoin">Join Room</button>
        </div>
        <div class="helper">Create로 생성된 코드를 상대에게 전달하세요. Join은 받은 코드를 입력합니다.</div>
      </div>
      <div class="statusWrap">
        <div class="status">
          <div id="srvDot" class="dot"></div><div>Server</div>
          <div class="retry" id="retry">↻ Retry</div>
        </div>
      </div>
    </div>
  </div>

  <div id="screen-connecting" class="screen" aria-hidden="true">
    <div class="title">Hold’em&SHOT.io</div>
    <div class="container">
      <div class="sketch" style="min-height:300px;display:flex;flex-direction:column;gap:16px;align-items:center;justify-content:center">
        <div class="spinner"></div>
        <div id="connectingText" style="font-size:36px;font-weight:900">Matching... <span id="count">12</span>s</div>
      </div>
    </div>
  </div>

  <div id="screen-play" class="screen" aria-hidden="true">
    <div class="wrap">
      <section class="board activePanel" id="board">
        <div class="phase">Phase: <span id="phaseText">Dealing</span> <span id="roundText" style="font-size:18px;opacity:.85">(Round 1)</span></div>
        <div class="p2"><span class="light" id="p2Light"></span> <span id="nameOpp">PLAYER2</span></div>

        <div class="handTop" id="oppHand"></div>
        <div class="shared" id="shared">
          <div class="card back"></div><div class="card back"></div><div class="card back"></div><div class="card back"></div><div class="card back"></div>
        </div>
        <div class="resultLine" id="resultLine"></div>
        <div class="handBottom" id="hand"></div>

        <div class="btns">
          <button id="btnReady" disabled>Ready</button>
          <button id="btnSurrender">Surrender</button>
        </div>

        <div class="p1"><span id="nameYou">PLAYER</span> <span class="light" id="p1Light"></span></div>
      </section>
      <div class="divider"></div>
      <section class="roulette" id="roulette">
        <div class="rwrap">
          <div style="position:relative">
            <div class="arrow"></div>
            <div class="drum" id="drum"><div class="centerDot"></div></div>
          </div>
          <div class="infoLine" id="rouletteInfo">Loser spins Russian Roulette (round = bullets)</div>
        </div>
      </section>
    </div>
  </div>

  <div id="rotate"><div class="box"><h2>Rotate to Landscape</h2><p>Mobile supports landscape only.</p></div></div>
  <div id="flash"></div>
`;

const $ = (id)=>document.getElementById(id);
const show = (n)=>{
  ["home","connecting","play"].forEach(s=>{
    const on = (s===n);
    $("screen-"+s).classList.toggle("active", on);
    $("screen-"+s).setAttribute("aria-hidden", on? "false":"true");
  });
};
const getNick = ()=> ($("nickname").value.trim() || "PLAYER");

/* ---------- 서버 핑 + 소켓 ---------- */
async function serverHealthy(timeoutMs=2000){
  try{
    const ctrl = new AbortController();
    const timer = setTimeout(()=>ctrl.abort(), timeoutMs);
    const r = await fetch(`${API_BASE}/health`, { signal: ctrl.signal, cache: "no-store" });
    clearTimeout(timer);
    if(!r.ok) return false;
  }catch(_){ return false; }
  try{
    await new Promise((res,rej)=>{
      const s = io(API_BASE,{transports:["websocket","polling"],timeout:timeoutMs,forceNew:true,autoConnect:true});
      const ok = ()=>{ try{s.disconnect();}catch{}; res(true); };
      const bad = ()=>{ try{s.disconnect();}catch{}; rej(new Error("connect_error")); };
      s.once("connect", ok); s.once("connect_error", bad);
      setTimeout(bad, timeoutMs);
    });
    return true;
  }catch(_){ return false; }
}
async function refreshServerDot(){ $("srvDot").classList.toggle("on", await serverHealthy()); }
refreshServerDot(); $("retry").onclick=(e)=>{ e.preventDefault(); refreshServerDot(); };

function initSocket(){
  if (socket && socket.connected) return;
  socket = io(API_BASE, { transports:["websocket","polling"] });

  socket.on("connect", ()=>{ myId = socket.id; });

  /* ---- 매칭/룸 ---- */
  socket.on("qm:queued", ()=>{});
  socket.on("qm:found", ({roomId, opponentNick, youNick})=>{
    if(matchTimer){ clearInterval(matchTimer); matchTimer=null; }
    currentRoomId = roomId;
    startPlayUI(youNick||getNick(), opponentNick||"PLAYER2");
  });
  socket.on("room:created", ({roomId})=>{ $("roomCode").value = roomId; });
  socket.on("room:ready", ({roomId, opponentNick, youNick})=>{
    currentRoomId = roomId;
    startPlayUI(youNick||getNick(), opponentNick||"PLAYER2");
  });
  socket.on("room:error", ({message})=> alert(message||"Room error"));
  socket.on("room:peer-left", ()=>{ alert("Opponent left."); location.reload(); });

  /* ---- 게임 상태 렌더 ---- */
  socket.on("game:state", renderFromState);

  /* ---- 쇼다운 결과 ---- */
  socket.on("round:result", onRoundResult);

  /* ---- 러시안 룰렛 ---- */
  socket.on("roulette:spin", onRouletteSpin);
}

/* ---------- 렌더링 ---------- */
function cardHTML(c){
  if(!c) return "";
  if(c.joker) return `<div class="big jokerLabel">JOKER</div>`;
  return `<div class="big">${c.rank}${c.suit}</div>`;
}
function inExchange(phase){ return phase==="flop-exchange" || phase==="turn-exchange" || phase==="river-exchange"; }

function renderFromState(S){
  if(isLocal) return; // (옵션) 로컬 모드일 경우 무시
  const youId = myId || socket?.id;
  const oppId = S.players.find(p=>p!==youId) || S.players[0];

  $("phaseText").textContent = S.phaseLabel;
  $("roundText").textContent = `(Round ${S.round})`;

  // 턴 라이트
  const ex = inExchange(S.phase);
  const myTurn = ex && S.turn === youId;
  $("p1Light").classList.toggle("on", !!myTurn);
  $("p2Light").classList.toggle("on", ex && !myTurn);

  // 결과 라인 유지/초기화
  if(!ex && S.phase!=="showdown") $("resultLine").textContent = "";

  // 상대 패 (쇼다운 단계 또는 forceReveal이면 오픈)
  const opp = $("oppHand"); opp.innerHTML="";
  const revealOpp = (S.phase==="showdown") || forceReveal;
  (S.hands[oppId]||[]).forEach(c=>{
    opp.insertAdjacentHTML("beforeend", `<div class="card ${revealOpp?'face':'back'}">${revealOpp?cardHTML(c):""}</div>`);
  });

  // 내 패
  const hand = $("hand"); hand.innerHTML="";
  (S.hands[youId]||[]).forEach((c,i)=>{
    const sel = selection.has(i) ? "selected" : "";
    hand.insertAdjacentHTML("beforeend", `<div class="card face ${sel}" data-idx="${i}">${cardHTML(c)}</div>`);
  });

  // 공유 카드
  const cells = [...document.querySelectorAll("#shared .card")];
  for(let i=0;i<5;i++){
    const cc = S.community[i];
    if(!cc || cc.back){ cells[i].className="card back"; cells[i].innerHTML=""; }
    else{ cells[i].className="card face"; cells[i].innerHTML=cardHTML(cc); }
  }

  // 버튼/선택 제어
  const btn = $("btnReady");
  if(ex){
    const canEx = !!S.canExchange[youId];
    btn.textContent = "Exchange / Done";
    btn.disabled = !canEx;

    selection = canEx ? selection : new Set(); // 내 턴 아닐 땐 선택 클리어
    // 클릭 선택 (최대 2장)
    if(canEx){
      hand.querySelectorAll(".card").forEach(el=>{
        el.onclick = ()=>{
          const idx = Number(el.dataset.idx);
          if(selection.has(idx)){ selection.delete(idx); el.classList.remove("selected"); }
          else{
            if(selection.size>=2) return;
            selection.add(idx); el.classList.add("selected");
          }
        };
      });
      btn.onclick = ()=>{
        const indices = Array.from(selection.values());
        socket.emit("exchange:request", { roomId: currentRoomId, indices }); // 0장도 허용(스킵)
        btn.disabled = true; // 중복 방지
        // 제출 즉시 선택 리셋
        selection.clear();
      };
    }else{
      hand.querySelectorAll(".card").forEach(el=> el.onclick=null);
      btn.onclick = null;
    }
  }else{
    // 비교환 페이즈: 버튼 비활성
    $("btnReady").textContent = "Ready";
    $("btnReady").disabled = true;
    $("btnReady").onclick = null;
    selection.clear();
    hand.querySelectorAll(".card").forEach(el=> el.onclick=null);
  }

  // 쇼다운 진입 시 강제 공개 플래그 on (결과 이벤트가 곧 온다)
  if(S.phase==="showdown"){ forceReveal = true; }
  // 새 라운드(deal)면 강제 공개 off
  if(S.phase==="deal"){ forceReveal = false; }

  // 항시 이름 유지
  // (room:ready에서 이미 세팅되지만 방어적으로 둠)
  $("nameYou").textContent ||= "YOU";
  $("nameOpp").textContent ||= "OPP";
}

/* ---------- 쇼다운 결과 ---------- */
function onRoundResult(payload){
  const { tie, winner, loser, winnerName, loserName, eval:ev } = payload;
  const you = myId || socket?.id;

  let msg="";
  if(tie){
    msg = `TIE — ${ev?.a?.name} vs ${ev?.b?.name}`;
  }else{
    const iWin = (winner===you);
    const wName = winnerName || "Winner";
    const lName = loserName || "Loser";
    msg = `${wName} wins (${(winner===you)?"YOU":wName}: ${ev?.a?.score? (winner===you?ev?.a?.name:ev?.b?.name):""}) — ${lName} (${(winner===you)?"OPP":"YOU"})`;
    if (ev?.a?.name && ev?.b?.name && !msg.includes("wins (")) {
      // 안전하게 양쪽 족보 병기
      msg = `${wName} wins — ${ev?.a?.name} vs ${ev?.b?.name}`;
    }
  }
  $("resultLine").textContent = msg;
}

/* ---------- 러시안 룰렛 ---------- */
const holesRef = []; // index -> hole Element
let drumSized = false;

function ensureDrum(){
  const drum = $("drum");
  if(drumSized && holesRef.length===6) return;

  // 초기화
  drum.innerHTML = `<div class="centerDot"></div>`;
  holesRef.length = 0;

  const rect = drum.getBoundingClientRect();
  const W = rect.width; const H = rect.height;
  const cx = W/2, cy = H/2;
  const r = Math.min(W,H)*0.35; // 원주 반경
  const holeSize = Math.min(W,H)*0.2;

  for(let i=0;i<6;i++){
    const angleDeg = -90 + i*60; // 0 index가 위쪽
    const rad = angleDeg * Math.PI / 180;
    const x = cx + r*Math.cos(rad) - holeSize/2;
    const y = cy + r*Math.sin(rad) - holeSize/2;
    const hole = document.createElement("div");
    hole.className = "hole";
    hole.style.width = hole.style.height = holeSize+"px";
    hole.style.left = x+"px";
    hole.style.top  = y+"px";
    drum.appendChild(hole);
    holesRef.push(hole);
  }
  drumSized = true;
}

window.addEventListener("resize", ()=>{ drumSized=false; ensureDrum(); });

function clearBullets(){
  holesRef.forEach(h=>{
    h.classList.remove("selected");
    const b = h.querySelector(".bullet");
    if(b) b.remove();
  });
}

function spinDrumTo(selected, bullets, fired){
  ensureDrum();
  clearBullets();

  // 총알 표시
  bullets.forEach(i=>{
    if(holesRef[i] && !holesRef[i].querySelector(".bullet")){
      const bb = document.createElement("div");
      bb.className = "bullet";
      holesRef[i].appendChild(bb);
    }
  });

  // 회전
  const drum = $("drum");
  const STEP = 60;
  const base = 720 + Math.floor(Math.random()*360); // 2~3회전 + 랜덤
  const target = base - (selected*STEP);
  requestAnimationFrame(()=>{ drum.style.transform = `rotate(${target}deg)`; });

  // 하이라이트 & 효과
  setTimeout(()=>{
    holesRef[selected]?.classList.add("selected");
    const info = $("rouletteInfo");
    if(fired){
      flashScreen();
      info.textContent = "BANG! — unlucky...";
    }else{
      info.textContent = "Click... alive.";
    }
  }, 2300);
}
function flashScreen(){
  const f = $("flash");
  f.classList.remove("flashOnce");
  void f.offsetWidth; // reflow
  f.classList.add("flashOnce");
}

function onRouletteSpin({ loser, bullets, selected, fired, round }){
  const you = myId || socket?.id;
  const iLose = (loser===you);
  $("rouletteInfo").textContent = `Round ${round}: ${iLose?"YOU":"OPP"} spins...`;
  spinDrumTo(selected, bullets, fired);
}

/* ---------- 공용 UI/버튼 ---------- */
function startPlayUI(nickYou, nickOpp){
  $("nameYou").textContent = nickYou || "YOU";
  $("nameOpp").textContent = nickOpp || "OPP";
  show("play");
  ensureDrum();
}

$("btnSurrender").onclick = ()=>{
  if(currentRoomId) socket?.emit("leaveRoom", { roomId: currentRoomId });
  location.reload();
};

$("btnCopy").onclick = ()=>{
  const v = $("roomCode").value.trim();
  if(v) navigator.clipboard.writeText(v);
};

/* ---------- 매칭 버튼 ---------- */
const randomAINick = ()=>{
  const a=["Swift","Silent","Cool","Neon","Crimson","Azure","Lucky","Wild","Ghost","Iron","Rapid","Mellow","Classic","Turbo","Cosmic"];
  const b=["Raven","Wolf","Tiger","Hawk","Viper","Falcon","Panda","Otter","Lynx","Cobra","Eagle","Shark","Bison","Koala","Gecko"];
  return `${a[Math.floor(Math.random()*a.length)]}_${b[Math.floor(Math.random()*a.length)]}_${Math.floor(Math.random()*90+10)}`;
};

$("btnQuick").onclick = async ()=>{
  const nick = getNick();
  const healthy = await serverHealthy().catch(()=>false);

  if(!healthy){
    // 오프라인 폴백 모드(선택): 서버 없이 싱글로 시작
    alert("Server offline. Local mode not supported in full flow build. Please start the server.");
    return;
  }

  initSocket();
  socket.emit("qm:join", { nick });
  show("connecting");

  let t = 12; $("count").textContent = t;
  matchTimer = setInterval(()=>{
    t--; $("count").textContent = t;
    if(t<=0){
      clearInterval(matchTimer); matchTimer=null;
      socket.emit("qm:leave");
      // 폴백 싱글 모드가 필요한 경우 여기에 붙일 수 있음
      alert("No opponent found. Try Create/Join to play with a friend.");
      location.reload();
    }
  }, 1000);
};

$("btnCreate").onclick = async ()=>{
  const healthy = await serverHealthy().catch(()=>false);
  if(!healthy){ alert("Server is offline."); refreshServerDot(); return; }
  initSocket();
  socket.emit("room:create", { nick:getNick() });
};
$("btnJoin").onclick = async ()=>{
  const healthy = await serverHealthy().catch(()=>false);
  if(!healthy){ alert("Server is offline."); refreshServerDot(); return; }
  const code = $("joinCode").value.trim().toUpperCase();
  if(!code) return alert("Enter room code.");
  initSocket();
  socket.emit("room:join", { roomId:code, nick:getNick() });
};

/* ---------- Service Worker (optional) ---------- */
if('serviceWorker' in navigator){
  window.addEventListener('load', ()=> navigator.serviceWorker.register('sw.js').catch(()=>{}));
}
</script>
</body>
</html>
