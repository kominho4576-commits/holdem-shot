<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<meta name="theme-color" content="#7c6cf4">
<title>Hold’em&SHOT.io</title>
<link rel="manifest" href="manifest.webmanifest">
<link rel="icon" href="icons/icon-192.png">
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js" defer></script>
<style>
:root{ --ink:#7c6cf4; --line:#c7c1ff; --soft:#e7e3ff; }
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:#fff;color:var(--ink);font-family:system-ui,-apple-system,"Apple SD Gothic Neo",Segoe UI,Roboto,Helvetica,Arial,"Noto Sans KR",sans-serif}
button{border:3px solid var(--ink); background:#fff; color:var(--ink); padding:.6rem 1rem; border-radius:18px; font-weight:900; cursor:pointer; box-shadow:0 0 0 3px var(--soft) inset}
button:disabled{opacity:.5;cursor:not-allowed}
input{border:3px solid var(--ink); background:#fff; color:var(--ink); padding:.6rem 1rem; border-radius:18px; font-weight:800; width:100%; box-shadow:0 0 0 3px var(--soft) inset}
.title{font-size:clamp(28px,6vw,64px);font-weight:900;text-align:center;margin:32px 0 16px}
.container{max-width:980px;margin:0 auto;padding:0 16px 40px}
.sketch{border:4px solid var(--line);border-radius:18px;box-shadow:0 0 0 3px var(--soft) inset;padding:20px 18px;max-width:820px;margin:18px auto;}
.row{display:grid;grid-template-columns:1fr auto;gap:12px;align-items:center}
.status{display:flex;align-items:center;gap:8px;margin-top:12px}
.statusWrap{max-width:820px;margin:8px auto 0;padding:0 2px}
.dot{width:12px;height:12px;border-radius:50%;background:#e44}
.dot.on{background:#2ecc71}
.retry{font-size:.9rem;text-decoration:underline;cursor:pointer}
.helper{margin-top:10px;opacity:.85;font-size:.9rem}
.screen{display:none}
.screen.active{display:block}

/* PLAY */
.wrap{min-height:100vh;display:grid;grid-template-columns:1fr 2px 0.78fr;gap:0}
.board,.roulette{ border:4px solid var(--line); border-radius:20px; position:relative; min-height: calc(100vh - 24px); }
.divider{background:var(--line)}
.phase{position:absolute; top:18px; left:18px; font-size:28px; font-weight:900;}
.p2{position:absolute; top:22px; right:24px; display:flex; align-items:center; gap:12px; font-size:34px; font-weight:900; z-index:3;}
.p1{position:absolute; left:22px; bottom:26px; display:flex; align-items:center; gap:12px; font-size:42px; font-weight:900;}
.light{width:14px;height:14px;border-radius:50%; border:3px solid var(--ink); background:#fff; display:inline-block;}
.light.on{ background:#43d17a; border-color:#43d17a }

.handTop{position:absolute; left:50%; transform:translateX(-50%); top:92px; display:flex; gap:22px; z-index:2;}
.shared{position:absolute; left:60px; right:60px; top:310px; display:grid; grid-template-columns:repeat(5,130px); gap:20px; justify-content:center; justify-items:center; align-items:center; z-index:1;}
.card{width:130px; aspect-ratio:2.5/3.5; border:5px solid var(--line); border-radius:14px; display:flex; align-items:center; justify-content:center; font-weight:900; font-size:42px; color:var(--ink); background:#fff; position:relative; overflow:hidden; box-shadow:0 0 0 3px var(--soft) inset; user-select:none; transition:.1s; text-align:center}
.card .big{font-size:42px; line-height:1; }
.card .big.jokerLabel{ font-size:28px; letter-spacing:1px; }
.back::before{content:""; position:absolute; inset:0; background:repeating-linear-gradient(45deg, rgba(124,108,244,.45) 0 10px, rgba(124,108,244,.15) 10px 20px); opacity:.85;}
.face{background:linear-gradient(180deg,#fff 70%, rgba(124,108,244,.08));}
.handBottom{position:absolute; left:60px; bottom:120px; display:flex; gap:22px; align-items:center; z-index:5;}
.resultLine{position:absolute; left:60px; right:60px; top:520px; text-align:center; font-weight:900; opacity:.95}
.btns{position:absolute; right:120px; bottom:34px; display:flex; gap:12px; align-items:flex-end; font-weight:800; z-index:6;}
.readyWrap{display:flex; flex-direction:column; align-items:flex-end; gap:6px;}
.readyCount{font-size:12px; opacity:.8; margin-right:2px;}

.rwrap{height:100%; display:grid; place-items:center}
.drum{position:relative; width:min(420px,72vh); aspect-ratio:1/1; border:5px solid var(--line); border-radius:50%; box-shadow:0 0 0 3px var(--soft) inset; display:grid; place-items:center; overflow:visible; transition: transform 2.2s cubic-bezier(.22,.8,.25,1);}
.centerDot{width:18px; height:18px; border-radius:50%; background:#7c6cf4; opacity:.6}
.hole{position:absolute; width:84px; height:84px; border-radius:50%; border:5px solid var(--line); background:#fff; display:grid; place-items:center; box-shadow:0 0 0 3px var(--soft) inset;}
.hole .bullet{width:46px; height:46px; border-radius:50%; background:#5b5b5b; box-shadow:inset 0 0 0 10px #2b2b2b;}
.hole.selected{outline:4px solid var(--ink); outline-offset:3px; animation:pulse 600ms ease-in-out 1;}
@keyframes pulse{0%{transform:scale(1)}60%{transform:scale(1.07)}100%{transform:scale(1)}}
.arrow{position:absolute; top:-22px; left:50%; transform:translateX(-50%); width:0;height:0;border-left:18px solid transparent;border-right:18px solid transparent;border-top:24px solid var(--ink);}
.infoLine{margin-top:8px;opacity:.85; text-align:center}
.activePanel{outline:4px solid var(--ink); outline-offset:-4px}
.card.selected{outline:4px solid var(--ink); box-shadow:0 0 0 3px var(--ink) inset}
.card.selected-opp{outline:4px dashed var(--ink);}
#rotate{position:fixed; inset:0; background:#fff; color:#7c6cf4; display:none; align-items:center; justify-content:center; text-align:center; padding:24px; z-index:1000;}
#flash{position:fixed; pointer-events:none; inset:0; background:rgba(255,0,0,0.28); opacity:0; z-index:999; }
@keyframes flash1 { 0%{opacity:0} 15%{opacity:1} 100%{opacity:0} }
.flashOnce{ animation: flash1 220ms ease-out 1; }
.spinner{width:40px;height:40px;border:5px solid var(--soft);border-top-color:var(--ink);border-radius:50%;animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
</style>
</head>
<body>
<div id="app"></div>

<script>
const API_BASE = "https://holdem-shot.onrender.com";

let socket = null;
let myId = null;
let matchTimer = null;
let currentRoomId = null;
let isLocal = false; // 오프라인 폴백 모드
let selection = new Set(); // 내 교환 선택 인덱스(최대 2)
let forceReveal = false;   // 쇼다운 이후 공개 유지

/* ---------- 공통 카드 유틸(클라에서도 사용) ---------- */
const SUITS=["♠","♥","♦","♣"];
const RANKS=["2","3","4","5","6","7","8","9","10","J","Q","K","A"];
const RANK_VAL=Object.fromEntries(RANKS.map((r,i)=>[r,i+2]));
const uniqKey=(c)=>c.joker?"J":`${c.rank}${c.suit}`;

function deckNew(){ const d=[]; for(const s of SUITS) for(const r of RANKS) d.push({rank:r,suit:s}); d.push({joker:true}); d.push({joker:true}); return d; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function drawNonJoker(S){ let c=S.deck.shift(); while(c && c.joker){ S.deck.push({joker:true}); shuffle(S.deck); c=S.deck.shift(); } return c; }

/* 족보 (서버와 동일 로직) */
function eval5(cards){ const ranks=cards.map(c=>RANK_VAL[c.rank]).sort((a,b)=>b-a); const suits=cards.map(c=>c.suit);
  const bySuit=new Map(); suits.forEach((s,i)=>{ if(!bySuit.has(s)) bySuit.set(s,[]); bySuit.get(s).push(ranks[i]); });
  const counts=new Map(); ranks.forEach(v=>counts.set(v,(counts.get(v)||0)+1));
  const groups=[...counts.entries()].sort((a,b)=> b[1]-a[1] || b[0]-a[0]);
  const isFlush=[...bySuit.values()].some(arr=>arr.length===5);
  const rset=[...new Set(ranks)];
  let isStraight=false, straightHigh=0;
  for(let i=0;i<=rset.length-1;i++){ const seq=[rset[i]]; for(let j=i+1;j<rset.length && seq.length<5;j++){ if(rset[j]===seq[seq.length-1]-1) seq.push(rset[j]); else if(rset[j]!==seq[seq.length-1]) break; } if(seq.length>=5){ isStraight=true; straightHigh=seq[0]; break; } }
  if(!isStraight && rset.includes(14) && [2,3,4,5].every(v=>rset.includes(v))){ isStraight=true; straightHigh=5; }
  if(isFlush){ for(const [s,arr] of bySuit.entries()){ const u=[...new Set(arr)].sort((a,b)=>b-a); let found=false, hi=0; for(let i=0;i<u.length;i++){ let seq=[u[i]]; for(let j=i+1;j<u.length && seq.length<5;j++){ if(u[j]===seq[seq.length-1]-1) seq.push(u[j]); else if(u[j]!==seq[seq.length-1]) break; } if(seq.length>=5){ found=true; hi=seq[0]; break; } } if(!found && u.includes(14) && [2,3,4,5].every(v=>u.includes(v))){ found=true; hi=5; } if(found) return {score:[9,hi], name:(hi===14?"Royal Flush":"Straight Flush")}; } }
  if(groups[0][1]===4){ const four=groups[0][0], kicker=groups.find(g=>g[0]!==four)[0]; return {score:[8,four,kicker], name:"Four of a Kind"}; }
  if(groups[0][1]===3 && (groups[1]?.[1]||0)>=2){ return {score:[7,groups[0][0],groups[1][0]], name:"Full House"}; }
  if(isFlush){ const arr=[...bySuit.values()].find(a=>a.length===5).sort((a,b)=>b-a); return {score:[6,...arr], name:"Flush"}; }
  if(isStraight) return {score:[5,straightHigh], name:"Straight"};
  if(groups[0][1]===3){ const kick=ranks.filter(v=>v!==groups[0][0]).slice(0,2); return {score:[4,groups[0][0],...kick], name:"Three of a Kind"}; }
  if(groups[0][1]===2 && groups[1]?.[1]===2){ const p1=groups[0][0], p2=groups[1][0]; const kick=ranks.filter(v=>v!==p1&&v!==p2)[0]; const hi=Math.max(p1,p2), lo=Math.min(p1,p2); return {score:[3,hi,lo,kick], name:"Two Pair"}; }
  if(groups[0][1]===2){ const p=groups[0][0]; const kick=ranks.filter(v=>v!==p).slice(0,3); return {score:[2,p,...kick], name:"One Pair"}; }
  return {score:[1,...ranks], name:"High Card"};
}
function bestHand7(cards7){
  const base=cards7.filter(c=>!c.joker); const jokers=cards7.length-base.length;
  const all=[]; for(const s of SUITS) for(const r of RANKS) all.push({rank:r,suit:s});
  const used=new Set(base.map(uniqKey)); const pool=all.filter(c=>!used.has(uniqKey(c)));
  function bestOf(a7){ let best=null; for(let a=0;a<7;a++) for(let b=a+1;b<7;b++){ const pick=[]; for(let i=0;i<7;i++) if(i!==a && i!==b) pick.push(a7[i]); const e=eval5(pick); if(!best || compareScore(e.score,best.score)>0) best=e; } return best; }
  function compareScore(a,b){ const n=Math.max(a.length,b.length); for(let i=0;i<n;i++){ const ai=a[i]||0, bi=b[i]||0; if(ai!==bi) return ai-bi; } return 0; }
  if(jokers===0) return bestOf(base);
  if(jokers===1){ let best=null; for(const sub of pool){ const e=bestOf([...base,sub]); if(!best || compareScore(e.score,best.score)>0) best=e; } return best; }
  let best=null; for(let i=0;i<pool.length;i++) for(let j=i+1;j<pool.length;j++){ const e=bestOf([...base,pool[i],pool[j]]); if(!best || compareScore(e.score,best.score)>0) best=e; }
  return best;
}

/* ---------- 앱 UI ---------- */
const app = document.getElementById("app");
app.innerHTML = `
  <div id="screen-home" class="screen active" aria-hidden="false">
    <div class="title">Hold’em&SHOT.io</div>
    <div class="container">
      <div class="sketch">
        <div class="row">
          <input id="nickname" placeholder="Nickname" />
          <button id="btnQuick">Quick Match</button>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="btnCreate">Create Room</button>
          <div style="display:grid;grid-template-columns:1fr auto;gap:8px;">
            <input id="roomCode" placeholder="Room Code" readonly />
            <button id="btnCopy">Copy</button>
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <input id="joinCode" placeholder="Enter Code to Join" />
          <button id="btnJoin">Join Room</button>
        </div>
        <div class="helper">Create로 생성된 코드를 상대에게 전달하세요. Join은 받은 코드를 입력합니다.</div>
      </div>
      <div class="statusWrap">
        <div class="status">
          <div id="srvDot" class="dot"></div><div>Server</div>
          <div class="retry" id="retry">↻ Retry</div>
        </div>
      </div>
    </div>
  </div>

  <div id="screen-connecting" class="screen" aria-hidden="true">
    <div class="title">Hold’em&SHOT.io</div>
    <div class="container">
      <div class="sketch" style="min-height:300px;display:flex;flex-direction:column;gap:16px;align-items:center;justify-content:center">
        <div class="spinner"></div>
        <div id="connectingText" style="font-size:36px;font-weight:900">Matching... <span id="count">12</span>s</div>
      </div>
    </div>
  </div>

  <div id="screen-play" class="screen" aria-hidden="true">
    <div class="wrap">
      <section class="board activePanel" id="board">
        <div class="phase">Phase: <span id="phaseText">Dealing</span> <span id="roundText" style="font-size:18px;opacity:.85">(Round 1)</span></div>
        <div class="p2"><span class="light" id="p2Light"></span> <span id="nameOpp">PLAYER2</span></div>

        <div class="handTop" id="oppHand"></div>
        <div class="shared" id="shared">
          <div class="card back"></div><div class="card back"></div><div class="card back"></div><div class="card back"></div><div class="card back"></div>
        </div>
        <div class="resultLine" id="resultLine"></div>
        <div class="handBottom" id="hand"></div>

        <div class="btns">
          <div class="readyWrap">
            <div class="readyCount" id="readyCount">0/2 Ready</div>
            <button id="btnReady" disabled>Ready</button>
          </div>
          <button id="btnSurrender">Surrender</button>
        </div>

        <div class="p1"><span id="nameYou">PLAYER</span> <span class="light" id="p1Light"></span></div>
      </section>
      <div class="divider"></div>
      <section class="roulette" id="roulette">
        <div class="rwrap">
          <div style="position:relative">
            <div class="arrow"></div>
            <div class="drum" id="drum"><div class="centerDot"></div></div>
          </div>
          <div class="infoLine" id="rouletteInfo">Loser spins Russian Roulette (round = bullets)</div>
        </div>
      </section>
    </div>
  </div>

  <div id="rotate"><div class="box"><h2>Rotate to Landscape</h2><p>Mobile supports landscape only.</p></div></div>
  <div id="flash"></div>
`;

const $ = (id)=>document.getElementById(id);
const show = (n)=>{ ["home","connecting","play"].forEach(s=>{ const on=(s===n); $("screen-"+s).classList.toggle("active",on); $("screen-"+s).setAttribute("aria-hidden",on?"false":"true"); }); };
const getNick = ()=> ($("nickname").value.trim() || "PLAYER");

/* ---------- 서버 상태 ---------- */
async function serverHealthy(timeoutMs=2000){
  try{
    const ctrl = new AbortController();
    const timer = setTimeout(()=>ctrl.abort(), timeoutMs);
    const r = await fetch(`${API_BASE}/health`, { signal: ctrl.signal, cache: "no-store" });
    clearTimeout(timer);
    if(!r.ok) return false;
  }catch(_){ return false; }
  try{
    await new Promise((res,rej)=>{
      const s = io(API_BASE,{transports:["websocket","polling"],timeout:timeoutMs,forceNew:true,autoConnect:true});
      const ok = ()=>{ try{s.disconnect();}catch{}; res(true); };
      const bad = ()=>{ try{s.disconnect();}catch{}; rej(new Error("connect_error")); };
      s.once("connect", ok); s.once("connect_error", bad);
      setTimeout(bad, timeoutMs);
    });
    return true;
  }catch(_){ return false; }
}
async function refreshServerDot(){ $("srvDot").classList.toggle("on", await serverHealthy()); }
refreshServerDot(); $("retry").onclick=(e)=>{ e.preventDefault(); refreshServerDot(); };

/* ---------- 소켓 ---------- */
function initSocket(){
  if (socket && socket.connected) return;
  socket = io(API_BASE, { transports:["websocket","polling"] });
  socket.on("connect", ()=>{ myId = socket.id; });

  socket.on("qm:queued", ()=>{});
  socket.on("qm:found", ({roomId, opponentNick, youNick})=>{
    if(matchTimer){ clearInterval(matchTimer); matchTimer=null; }
    currentRoomId = roomId;
    startPlayUI(youNick||getNick(), opponentNick||"PLAYER2");
  });
  socket.on("room:created", ({roomId})=>{ $("roomCode").value = roomId; });
  socket.on("room:ready", ({roomId, opponentNick, youNick})=>{
    currentRoomId = roomId;
    startPlayUI(youNick||getNick(), opponentNick||"PLAYER2");
  });
  socket.on("room:error", ({message})=> alert(message||"Room error"));
  socket.on("room:peer-left", ()=>{ alert("Opponent left."); location.reload(); });

  socket.on("game:state", renderFromState);
  socket.on("round:result", onRoundResult);
  socket.on("roulette:spin", onRouletteSpin);
}

/* ---------- 렌더 ---------- */
function cardHTML(c){ if(!c) return ""; return c.joker ? `<div class="big jokerLabel">JOKER</div>` : `<div class="big">${c.rank}${c.suit}</div>`; }
function inExchange(p){ return p==="flop-exchange"||p==="turn-exchange"||p==="river-exchange"; }

function renderFromState(S){
  const youId = isLocal ? "you" : (myId || socket?.id);
  const oppId = S.players.find(p=>p!==youId) || S.players[0];

  $("phaseText").textContent = S.phaseLabel;
  $("roundText").textContent = `(Round ${S.round})`;

  const ex = inExchange(S.phase);
  const myTurn = ex && S.turn === youId;
  $("p1Light").classList.toggle("on", !!myTurn);
  $("p2Light").classList.toggle("on", ex && !myTurn);

  if(!ex && S.phase!=="showdown") $("resultLine").textContent = "";

  const opp = $("oppHand"); opp.innerHTML="";
  const revealOpp = (S.phase==="showdown") || forceReveal || isLocal;
  (S.hands[oppId]||[]).forEach(c=>{
    opp.insertAdjacentHTML("beforeend", `<div class="card ${revealOpp?'face':'back'}">${revealOpp?cardHTML(c):""}</div>`);
  });

  const hand = $("hand"); hand.innerHTML="";
  (S.hands[youId]||[]).forEach((c,i)=>{
    const sel = selection.has(i) ? "selected" : "";
    hand.insertAdjacentHTML("beforeend", `<div class="card face ${sel}" data-idx="${i}">${cardHTML(c)}</div>`);
  });

  const cells = [...document.querySelectorAll("#shared .card")];
  for(let i=0;i<5;i++){
    const cc = S.community[i];
    if(!cc || cc.back){ cells[i].className="card back"; cells[i].innerHTML=""; }
    else{ cells[i].className="card face"; cells[i].innerHTML=cardHTML(cc); }
  }

  const btn = $("btnReady");
  const rc = $("readyCount");
  if(rc){
    const readyNum = S.players.reduce((n,p)=> n + (S.ready?.[p] ? 1 : 0), 0);
    rc.textContent = `${readyNum}/${S.players.length} Ready`;
  }

  if(ex){
    const canEx = !!S.canExchange[youId];
    btn.textContent = "Exchange / Done";
    btn.disabled = !canEx;

    selection = canEx ? selection : new Set();
    if(canEx){
      hand.querySelectorAll(".card").forEach(el=>{
        el.onclick = ()=>{
          const idx = Number(el.dataset.idx);
          if(selection.has(idx)){ selection.delete(idx); el.classList.remove("selected"); }
          else{ if(selection.size>=2) return; selection.add(idx); el.classList.add("selected"); }
        };
      });
      btn.onclick = ()=>{
        const indices = Array.from(selection.values());
        if(isLocal) LocalGame.exchange(indices);
        else socket.emit("exchange:request", { roomId: currentRoomId, indices });
        btn.disabled = true;
        selection.clear();
      };
    }else{
      hand.querySelectorAll(".card").forEach(el=> el.onclick=null);
      btn.onclick = null;
    }
  }else{
    btn.textContent = "Ready";
    const youReady = !!S.ready?.[youId];
    btn.disabled = youReady ? true : !S.allowReady?.[youId];
    btn.onclick = ()=>{
      if(btn.disabled) return;
      if(isLocal) LocalGame.playerReady(); else socket.emit("player:ready", { roomId: currentRoomId });
      btn.disabled = true;
    };
    $("hand").querySelectorAll(".card").forEach(el=> el.onclick=null);
    selection.clear();
  }

  if(S.phase==="showdown"){ forceReveal = true; }
  if(S.phase==="deal"){ forceReveal = false; }

  $("nameYou").textContent ||= "YOU";
  $("nameOpp").textContent ||= "OPP";
}

/* ---------- 쇼다운/룰렛 UI ---------- */
const holesRef = []; let drumSized = false;
function ensureDrum(){ const drum=$("drum"); if(drumSized && holesRef.length===6) return;
  drum.innerHTML=`<div class="centerDot"></div>`; holesRef.length=0;
  const rect=drum.getBoundingClientRect(); const W=rect.width, H=rect.height;
  const cx=W/2, cy=H/2, r=Math.min(W,H)*0.35, holeSize=Math.min(W,H)*0.2;
  for(let i=0;i<6;i++){ const angle=-90+i*60, rad=angle*Math.PI/180; const x=cx+r*Math.cos(rad)-holeSize/2, y=cy+r*Math.sin(rad)-holeSize/2;
    const hole=document.createElement("div"); hole.className="hole"; hole.style.width=hole.style.height=holeSize+"px"; hole.style.left=x+"px"; hole.style.top=y+"px"; drum.appendChild(hole); holesRef.push(hole); }
  drumSized=true;
}
window.addEventListener("resize", ()=>{ drumSized=false; ensureDrum(); });
function clearBullets(){ holesRef.forEach(h=>{ h.classList.remove("selected"); const b=h.querySelector(".bullet"); if(b) b.remove(); }); }
function spinDrumTo(selected, bullets, fired){ ensureDrum(); clearBullets(); bullets.forEach(i=>{ if(holesRef[i] && !holesRef[i].querySelector(".bullet")){ const bb=document.createElement("div"); bb.className="bullet"; holesRef[i].appendChild(bb); } });
  const drum=$("drum"); const STEP=60, base=720+Math.floor(Math.random()*360); const target=base-(selected*STEP);
  requestAnimationFrame(()=>{ drum.style.transform=`rotate(${target}deg)`; });
  setTimeout(()=>{ holesRef[selected]?.classList.add("selected"); const info=$("rouletteInfo"); if(fired){ flashScreen(); info.textContent="BANG! — unlucky..."; } else { info.textContent="Click... alive."; } }, 2300);
}
function flashScreen(){ const f=$("flash"); f.classList.remove("flashOnce"); void f.offsetWidth; f.classList.add("flashOnce"); }
function onRoundResult(payload){ const { tie, winnerName, loserName, eval:ev } = payload;
  $("resultLine").textContent = tie ? `TIE — ${ev?.a?.name} vs ${ev?.b?.name}` : `${winnerName||"Winner"} wins — ${ev?.a?.name ?? ""} vs ${ev?.b?.name ?? ""}`;
}
function onRouletteSpin({ loser, bullets, selected, fired, round }){ const you = isLocal? "you" : (myId||socket?.id); const iLose=(loser===you);
  $("rouletteInfo").textContent = `Round ${round}: ${iLose?"YOU":"OPP"} spins...`; spinDrumTo(selected, bullets, fired);
}

/* ---------- 로컬 AI 게임 엔진 ---------- */
const LocalGame = (()=>{
  const S = {
    round:1, deck:[], players:["you","ai"],
    hands:{you:[], ai:[]},
    community:[{back:true},{back:true},{back:true},{back:true},{back:true}],
    phase:"deal", phaseLabel:"Dealing",
    turn:"you",
    acted:{you:false, ai:false},
    canExchange:{you:false, ai:false},
    phaseExchangeLeft:{you:2, ai:2},
    ready:{you:false, ai:false},
    allowReady:{you:true, ai:true},
  };

  function setPhase(phase){
    S.phase = phase;
    S.phaseLabel = phase==="deal"?"Dealing":
                   phase==="flop-exchange"?"Flop (Exchange)":
                   phase==="turn-exchange"?"Turn (Exchange)":
                   phase==="river-exchange"?"River (Final Exchange)":
                   "Showdown";
    for(const p of S.players){ S.ready[p]=false; S.allowReady[p]=true; }
    const isEx = ["flop-exchange","turn-exchange","river-exchange"].includes(phase);
    if(isEx){
      for(const p of S.players){ S.acted[p]=false; S.phaseExchangeLeft[p]=2; }
      S.turn = Math.random()<0.5? "you":"ai";
      for(const p of S.players){ S.canExchange[p]=(p===S.turn); }
      renderFromState(S);
      if(S.turn==="ai") setTimeout(aiExchange, 450); // AI 먼저면 바로 수행
    }else{
      for(const p of S.players){ S.canExchange[p]=false; }
      renderFromState(S);
    }
  }

  function newRound(){
    S.deck = shuffle(deckNew());
    S.community=[{back:true},{back:true},{back:true},{back:true},{back:true}];
    S.hands.you=[S.deck.shift(), S.deck.shift()];
    S.hands.ai=[S.deck.shift(), S.deck.shift()];
    setPhase("deal");
    setTimeout(progressPhase, 600);
  }

  function progressPhase(){
    switch(S.phase){
      case "deal":
        S.community[0]=drawNonJoker(S); S.community[1]=drawNonJoker(S); S.community[2]=drawNonJoker(S);
        setPhase("flop-exchange"); break;
      case "flop-exchange":
        S.community[3]=drawNonJoker(S); setPhase("turn-exchange"); break;
      case "turn-exchange":
        S.community[4]=drawNonJoker(S); setPhase("river-exchange"); break;
      case "river-exchange":
        setPhase("showdown"); renderFromState(S); setTimeout(showdown, 120); break;
      case "showdown": break;
    }
  }

  function exchange(indices){
    if(S.phase==="showdown") return;
    if(S.turn!=="you" || S.acted.you) return;
    const allowed = Math.max(0, Math.min(2, S.phaseExchangeLeft.you||0));
    const unique = Array.from(new Set(indices.map(n=>Number(n)))).filter(i=> i>=0 && i<S.hands.you.length).slice(0,allowed);
    for(const idx of unique){ S.hands.you[idx] = S.deck.shift(); }
    S.phaseExchangeLeft.you = Math.max(0, (S.phaseExchangeLeft.you||0) - unique.length);
    S.acted.you = true;

    if(S.acted.ai){
      progressPhase();
    }else{
      S.turn = "ai"; S.canExchange.you=false; S.canExchange.ai=true; renderFromState(S);
      setTimeout(aiExchange, 450);
    }
  }

  function aiExchange(){
    if(S.acted.ai || !["flop-exchange","turn-exchange","river-exchange"].includes(S.phase)) return;
    const keep = decideAIKeep(); // boolean[2] for ai hole
    const swapIdx=[];
    for(let i=0;i<2;i++){ if(!keep[i] && swapIdx.length<2) swapIdx.push(i); }
    for(const idx of swapIdx){ S.hands.ai[idx] = S.deck.shift(); }
    S.phaseExchangeLeft.ai = Math.max(0,(S.phaseExchangeLeft.ai||0)-swapIdx.length);
    S.acted.ai = true;

    if(S.acted.you){
      progressPhase();
    }else{
      S.turn = "you"; S.canExchange.you=true; S.canExchange.ai=false; renderFromState(S);
    }
  }

  // 아주 단순한 휴리스틱: 조커/페어/높은 카드/플러시 가능성 유지
  function decideAIKeep(){
    const h=S.hands.ai, c=S.community.filter(x=>!x.back);
    const keep=[false,false];
    const ranks = (i)=> h[i].joker? 15 : RANK_VAL[h[i].rank];
    const suits = (i)=> h[i].suit;
    // 조커는 항상 보존
    for(let i=0;i<2;i++) if(h[i].joker) keep[i]=true;
    // 페어면 둘 다 보존
    if(!h[0].joker && !h[1].joker && h[0].rank===h[1].rank){ keep[0]=keep[1]=true; }
    // 커뮤니티에 같은 무늬 많이 있으면 그 무늬 보존
    const suitCount={}; c.forEach(cc=>{ if(!cc.joker && cc.suit) suitCount[cc.suit]=(suitCount[cc.suit]||0)+1; });
    const bestSuit = Object.entries(suitCount).sort((a,b)=>b[1]-a[1])[0]?.[0];
    if(bestSuit){ for(let i=0;i<2;i++) if(suits(i)===bestSuit) keep[i]=true; }
    // 높은 카드(A,K,Q,J,10)는 보존 경향
    for(let i=0;i<2;i++) if(ranks(i)>=11) keep[i]=true;
    return keep;
  }

  function playerReady(){
    S.ready.you = true; renderFromState(S);
    // AI는 즉시 Ready
    S.ready.ai = true; renderFromState(S);
    if(!["flop-exchange","turn-exchange","river-exchange"].includes(S.phase)){
      setTimeout(progressPhase, 200);
    }
  }

  function showdown(){
    const a7=[...S.hands.you, ...S.community.filter(c=>!c.back)];
    const b7=[...S.hands.ai,  ...S.community.filter(c=>!c.back)];
    const Ea=bestHand7(a7), Eb=bestHand7(b7);
    function cmp(x,y){ const n=Math.max(x.score.length,y.score.length); for(let i=0;i<n;i++){ const xi=x.score[i]||0, yi=y.score[i]||0; if(xi!==yi) return xi-yi; } return 0; }
    const diff=cmp(Ea,Eb);
    let tie=false, winner=null, loser=null;
    if(diff===0) tie=true; else if(diff>0){ winner="you"; loser="ai"; } else { winner="ai"; loser="you"; }
    onRoundResult({ tie, winner, loser, winnerName: winner==="you"?"YOU":"OPP", loserName: loser==="you"?"YOU":"OPP", eval:{a:Ea,b:Eb} });

    if(tie){
      setTimeout(nextRound, 2000); return;
    }
    // 룰렛
    const HOLES=6; const bulletsCount=Math.min(6,S.round);
    const all=[0,1,2,3,4,5]; shuffle(all);
    const bullets=all.slice(0,bulletsCount).sort((x,y)=>x-y);
    const selected=Math.floor(Math.random()*HOLES);
    const fired=bullets.includes(selected);
    onRouletteSpin({ loser, bullets, selected, fired, round:S.round });
    setTimeout(nextRound, 3000);
  }

  function nextRound(){
    S.round += 1;
    newRound();
  }

  function start(nickYou, nickOpp){
    isLocal = true;
    myId = "you";
    $("nameYou").textContent = nickYou || "YOU";
    $("nameOpp").textContent = nickOpp || "OPP";
    show("play"); ensureDrum();
    newRound();
  }

  return { start, exchange, playerReady };
})();

/* ---------- 공용 버튼 ---------- */
function randomAINick(){ const a=["Swift","Silent","Cool","Neon","Crimson","Azure","Lucky","Wild","Ghost","Iron","Rapid","Mellow","Classic","Turbo","Cosmic"];
  const b=["Raven","Wolf","Tiger","Hawk","Viper","Falcon","Panda","Otter","Lynx","Cobra","Eagle","Shark","Bison","Koala","Gecko"];
  return `${a[Math.floor(Math.random()*a.length)]}_${b[Math.floor(Math.random()*a.length)]}_${Math.floor(Math.random()*90+10)}`;
}

function startPlayUI(nickYou, nickOpp){ $("nameYou").textContent=nickYou||"YOU"; $("nameOpp").textContent=nickOpp||"OPP"; show("play"); ensureDrum(); }
$("btnSurrender").onclick = ()=>{ if(!isLocal && currentRoomId) socket?.emit("leaveRoom", { roomId: currentRoomId }); location.reload(); };
$("btnCopy").onclick = ()=>{ const v=$("roomCode").value.trim(); if(v) navigator.clipboard.writeText(v); };

/* ---------- 매칭 버튼 ---------- */
$("btnQuick").onclick = async ()=>{
  const nick = getNick();
  const healthy = await serverHealthy().catch(()=>false);

  if(!healthy){
    // 🔸 서버 오프라인 → 즉시 로컬 AI전
    startPlayUI(nick, randomAINick());
    LocalGame.start(nick, randomAINick()); // 이름 세팅은 startPlayUI로도 됨
    return;
  }

  // 온라인 멀티
  initSocket();
  socket.emit("qm:join", { nick });
  show("connecting");

  let t=12; $("count").textContent=t;
  matchTimer = setInterval(()=>{
    t--; $("count").textContent=t;
    if(t<=0){
      clearInterval(matchTimer); matchTimer=null;
      socket.emit("qm:leave");
      // 타임아웃 → 로컬 AI전
      startPlayUI(nick, randomAINick());
      LocalGame.start(nick, randomAINick());
    }
  },1000);
};

$("btnCreate").onclick = async ()=>{
  const healthy = await serverHealthy().catch(()=>false);
  if(!healthy){ // 오프라인에서는 방 기능 없음 → 안내 후 AI전 권유
    if(confirm("Server offline. Play vs AI instead?")){ startPlayUI(getNick(), randomAINick()); LocalGame.start(getNick(), randomAINick()); }
    return;
  }
  initSocket(); socket.emit("room:create", { nick:getNick() });
};
$("btnJoin").onclick = async ()=>{
  const healthy = await serverHealthy().catch(()=>false);
  if(!healthy){ alert("Server is offline. Use Quick Match to play vs AI."); return; }
  const code=$("joinCode").value.trim().toUpperCase(); if(!code) return alert("Enter room code.");
  initSocket(); socket.emit("room:join", { roomId:code, nick:getNick() });
};

/* ---------- SW (optional) ---------- */
if('serviceWorker' in navigator){
  window.addEventListener('load', ()=> navigator.serviceWorker.register('sw.js').catch(()=>{}));
}
</script>
</body>
</html>
